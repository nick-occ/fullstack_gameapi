What additional properties did you add to your models and why?
To the Game model I added a function to make a move on the Tic-Tac-Toe grid.  With making a move also comes additional steps such as checking if the move results in a win, if so updating the score for each player’s total score and if no moves remain issuing a draw.  Also, the game is designed to work with one or two players.  I added logic so that when only one user was provided when creating the game a random move will be auto generated after the user makes their move.  Extra logic had to run when game was in single vs. two player mode.  In the Game object in the data store I added a field “moves_remaining’ that gets decremented after each move.  This is useful because I am able to reference this to determine whether the game is over and the result is a draw, I also use this in the Score object as a tiebreaker to keep track of the least amount of moves that result in a win for each user.

What were some of the trade-offs or struggles you faced when implementing the new game logic?
With the Tic-Tac-Toe grid I decided to make the grid a standard list rather than a multi-dimensional array.  It was easier to add values during each move to a single list than using a numpy array within the Google Cloud Platform API.  Another struggle I faced when working with the platform and implementing my game was the lack of ability to set break points in your code and debug errors.  I would have to deploy and then check the logs to see where the errors were occurring.  Another struggle was querying a Kind object from the data store using a key from a different Kind object.  This was mostly for linking between the Game kind because there were other object in the data store such as the Score and Game History objects that were created when certain conditions in the Game object were met.
